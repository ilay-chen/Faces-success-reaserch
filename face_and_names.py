# -*- coding: utf-8 -*-
"""face-and-names.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fxgNPuenO8aHcuC-hgVgtJAME2AKv7Wz
"""

import numpy as np
import tensorflow as tf 
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, Activation, Flatten, Conv2D, MaxPooling2D

pip install opencv-python

# check opencv version
import cv2
# print version number
print(cv2.__version__)

from cv2 import imread
from cv2 import CascadeClassifier

# perform face detection
bboxes = classifier.detectMultiScale(pixels)
# print bounding box for each detected face
for box in bboxes:
	print(box)

from google.colab import drive
drive.mount('/content/drive')

import zipfile
path_to_zip_file = "drive/My Drive/academy research/exercise/faces_fr_female_source.zip"
directory_to_extract_to = "drive/My Drive/academy research/exercise/females"
with zipfile.ZipFile(path_to_zip_file, 'r') as zip_ref:
    zip_ref.extractall(directory_to_extract_to)

# Commented out IPython magic to ensure Python compatibility.
#init
import numpy as np
import tensorflow as tf
from cv2 import imread
from cv2 import imshow
from cv2 import waitKey
from cv2 import destroyAllWindows
from cv2 import CascadeClassifier
from cv2 import rectangle
# %matplotlib inline
from matplotlib import pyplot as plt
# load the pre-trained model
classifier = CascadeClassifier('drive/My Drive/academy research/exercise/haarcascade_frontalface_default.xml')

folders = tf.io.gfile.listdir(directory_to_extract_to)
#npp = np.array(folders)
for folder in folders:
  if not "." in folder and "amandine" in folder:
    pics = tf.io.gfile.listdir(directory_to_extract_to + "/" + folder)
    #print(pics)
    b = np.array(pics)
    procces_image(b)
    print(b)
    #npp = np.hstack((npp, b))

drive.flush_and_unmount()

firstline = True
for arr in npp:
  if firstline:
    firstline = False
    titles = arr
    continue
  procces_image(arr)

path_to_prosses = "drive/My Drive/academy research/exercise/females_ready/"
def procces_image(row_images):
  i = 0
  for image_name in row_images:
    folder_name = image_name.split("_")[0]
    long_path = directory_to_extract_to + "/" + folder_name + "/" + image_name
    print(long_path)
    pixels = imread(long_path)
    newpix = detect_face(pixels)
    path_to_save = path_to_prosses + folder_name + "/" + folder_name + "_" + str(i) + ".jpeg"
    plt.imshow(newpix)
    plt.show()
    save_image(newpix, path_to_save)
    i += 1

def save_image(img, path):
  gray = tf.image.rgb_to_grayscale(img)
  enc = tf.image.encode_jpeg(gray)
  tf.io.write_file(path, enc)

def detect_face(img):
  bboxes = classifier.detectMultiScale(img)
  for box in bboxes:
    x, y, width, height = box
    box = [y, x, width, height]
    return tf.image.crop_to_bounding_box(img, box[0], box[1], box[2], box[3])
  return img

# Commented out IPython magic to ensure Python compatibility.
# plot photo with detected faces using opencv cascade classifier
from cv2 import imread
from cv2 import imshow
from cv2 import waitKey
from cv2 import destroyAllWindows
from cv2 import CascadeClassifier
from cv2 import rectangle
# %matplotlib inline
from matplotlib import pyplot as plt
# load the photograph
pixels = imread('test1.jpg')
# load the pre-trained model
classifier = CascadeClassifier('haarcascade_frontalface_default.xml')
# perform face detection
bboxes = classifier.detectMultiScale(pixels)
# print bounding box for each detected face
for box in bboxes:
	# extract
	x, y, width, height = box
	x2, y2 = x + width, y + height
	# draw a rectangle over the pixels
	rectangle(pixels, (x, y), (x2, y2), (0,0,255), 1)
# show the image
#imshow('face detection', pixels)
plt.imshow(pixels)
plt.show()

for box in bboxes:
#box = bboxes[0]
# extract
  x, y, width, height = box
# draw a rectangle over the pixels
  box = [y, x, width, height]
  print(box)
  cropped_image_tensor = tf.image.crop_to_bounding_box(pixels, box[0], box[1], box[2], box[3])
  plt.imshow(cropped_image_tensor)
  plt.show()

gray = tf.image.rgb_to_grayscale(cropped_image_tensor)
enc = tf.image.encode_jpeg(gray)
tf.io.write_file("file1.jpg", enc)

for box in bboxes:
  newpixels = (pixels, box)
#print(newpixels)
for inn in newpixels:
  plt.imshow(inn)
  plt.show()

def crop_image(img, crop):
    return tf.image.crop_to_bounding_box(img,
                                         crop[0],
                                         crop[1],
                                         crop[2],
                                         crop[3])

from google.colab import files
uploaded = files.upload()

for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

from google.colab import drive
drive.mount('/content/drive')

